# 软件过程与工具

## 概论

#### 软件基本概念

##### 定义：

一组对象或项目所形成的一个“配置”，由**程序、文档和数据**等部分构成。

##### 特征：

复杂性，不可见性，易变性，一致性

#### 软件工程基本概念

##### 历史：

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200107200715187.png" alt="image-20200107200715187" style="zoom: 80%;" />

##### 定义：

–软件开发过程(分析、设计、实现、测试、运行、维护)

–软件开发中应遵循的原则和管理技术

–软件开发中所采用的技术和工具





## 软件工程核心思想

* 软件设计过程：从现实空间的需求到计算机空间的软件代码之间的映射与转换

  软件工程：用严格的规范和管理手段来缩小偏差，通过牺牲“时间”来提高“质量”

### 目标：

* 不同目标之间的关系—折中(tradeoff)

##### 功能性需求

完备性，正确性，健壮性，可靠性

##### 非功能性需求

效率，可用性，可维护性，可移植性，清晰性，安全性，兼容性，经济性，商业质

### 多角色

* 在软件开发过程中同样需要多种角色之间紧密协作，才能高质量、高效率的完成任务

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200107202412534.png" alt="image-20200107202412534" style="zoom: 80%;" />

### 四个核心概念

##### 分治

* 将复杂问题分解为若干可独立解决的简单子问题，并分别独立求解，以降低复杂性
* 然后再将各子问题的解综合起来，形成最初复杂问题的解

##### 复用

* 复用已经成功使用的架构、框架、同类经验的团队
* 直接使用已有的软构件，即可组装成新的系统
* 复用已有的功能模块，既可以提高开发效率，也可以改善新开发过程中带来的质量问题

##### 折中

* 不同的需求之间往往存在矛盾与冲突，需要通过折中来作出的合理的取舍，找到使双方均满意的点

##### 演化

* 在设计软件的初期，就要充分考虑到未来可能的变化，并采用恰当的设计决策，使软件具有适应变化的能力

> 可修改性、可维护性、可扩展性





## 软件过程模型

### 瀑布模型

![image-20200107203056071](C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200107203056071.png)

- 上一个阶段结束，下一个阶段才能开始

- 每个阶段均有里程碑和提交物

- 上一阶段的输出是下一阶段的输入

- 每个阶段均需要进行V&V

- 侧重于文档与产出物

  **很难向前回溯**

优点：追求效率

缺点：过于理想化

> 需求很难一开始就确定，开发人员与用户之间缺乏有效沟通，客户最后才能得到可执行程序



###  增量过程模型

#### 增量模型

![image-20200107203816060](C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200107203816060.png)

* 以迭代的方式运用瀑布模型

* **第一个增量往往是核心产品**：满足了基本的需求，但是缺少附加的特性

  客户使用上一个增量的提交物并进行自己评价，制定下一个增量计划，说明需要增加的特性和功能

  重复上述过程，直到最终产品产生为止

优点：在时间要求较高的情况下交付产品，人员分配灵活，逐步增加产品功能，降低项目总体性失败风险

缺点：需要协调好各增量之间的关系，无法处理需求发生变更的情况，加入增量时不能破坏原来已经构造好的软件

#### RAD模型 

![image-20200107205553595](C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200107205553595.png)

* 侧重于**短开发周期**的增量过程模型，是瀑布模型的**高速变体**，通过**基于构件的构建方法**实现快速开发
* 多个团队并行进行开发，但启动时间有先后，先启动团队的提交物将作为后启动团队的输入

缺点：人力资源需求大，需要做充足的准备，系统需要合理模块化，技术风险很高时不宜采用



### 演化过程模型

#### 快速原型法

![image-20200107212624798](C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200107212624798.png)

![image-20200107212629888](C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200107212629888.png)

Step 1：双方通过沟通，明确已知的需求，并大致勾画出以后再进一步
       定义的东西

Step 2：迅速策划一个原型开发迭代并进行建模，主要集中于那些最终
      用户所能够看到的内容，如人机接口布局或者输出显示格式等

Step 3：快速设计产生原型，对原型进行部署，由客户和用户进行评价

Step 4：根据反馈，进一步细化需求并调整原型

Step 5：原型系统不断调整以逼近用户需求

* 原型类型：

  * 抛弃式原型

    `最初的原型在完成并得到用户认可之后，将不会作为交付给用户的最终系统的一部分，而是被抛弃，其目的只是为了收集与验证需求`

    `该类原型可能是不可执行的(例如，只包含用户界面)`

  * 演化式原型

    `最初构造的原型将具备较高的质量，包含了系统的核心功能，然后通过收集需求对其进行不断的改善和精化`

    `该类原型是可执行的，将成为最终系统的一部分`

优点：提高和改善客户/用户的参与程度，最大程度的响应用户需求的变化

缺点：未考虑整体质量和长期可维护性，可能混淆原型与最终系统，会产生额外的开发费用

#### 螺旋式过程模型

![image-20200107222956630](C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200107222956630.png)

* 螺旋模型沿着螺线旋转，在四个象限内表达四个方面的活动：

  制定计划：确定软件目标，选定实施方案，弄清项目开发的限制

  风险分析：分析所选方案，考虑如何识别和消除风险

  实施工程：实施软件开发

  客户评估：评价开发工作，提出修正建议

优点：风险驱动型过程模型，支持复用

缺点：适用于大规模软件项目，周期长，成本高



### 形式化过程模型

![image-20200107225942888](C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200107225942888.png)

* 使用严格的数学形式来刻画每一阶段的产物(需求、设计、程序、测试)
* 应用一系列形式化方法在各阶段的产物之间进行自动/半自动的转换

优点：可以有效避免歧义性，不完整性，不一致性等问题，目标是**”提供无缺陷的软件“**

缺点：理解性、可视性差，耗时成本高，有些情景难以用形式化模型表述

应用场合：对可靠性和安全性要求较高的关键系统（太过理想化，实践中少见）

### 面向复用的软件过程

* 从已有的软件单元（软构件）入手来构造系统

  * 主要过程：

    需求分析$\Rightarrow$体系结构设计$\Rightarrow$构件获取(购买、重新开发)$\Rightarrow$构件修改与测试$\Rightarrow$构件组装$\Rightarrow$集成测试





## 敏捷方法与过程

* 以快速的增量和迭代方式进行软件开发

### 极限编程(XP)

![image-20200107233048765](C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200107233048765.png)

#### 计划阶段

* 倾听顾客陈述，形成一组“**用户故事(user stories)**” ，描述其输出、特性、功能等
* 按照价值或风险排序：顾客为每个用户故事指定**优先级(Priority)**
* XP团队评估各个用户故事，为其**指定成本(Cost, 开发周数)**，若超过3周，则拆分
* 将若干个用户故事指定为下一次发布的增量，确定发布日期：

* 规划**整体进度(project velocity)**：以怎样的速度开展项目
* 顾客可以在开发过程中扩展新故事、去除原有故事、改变优先级、拆分等

#### 设计阶段

* KIS(Keep It Simple)原则

* 设计模型：面向对象方法，CRC卡片(Class-Responsibility-Collaborator)

   ![img](https://p-blog.csdn.net/images/p_blog_csdn_net/onight/EntryImages/20091201/crcCardLayout.jpg)

* 遇到困难问题，创建“Spike Solutions”(原型)

* 对设计方案不断重构(Refactoring)（遵循US的外特性要求，改善内部结构，消除bug，提高效率，提高易读性等等）

#### 编码与测试阶段

##### XP Coding

* 在编码之前，根据用户故事设计单元测试用例
* 结对编程(Pair programming)：两人一起编程，实时讨论、实时评审
* 测试驱动的开发(TDD)：先写测试用例，再写代码

##### XP Testing

- 自动化单元测试(Unit test)
- 持续集成(Continuous Integration)
- 持续进行回归测试(Regression test)
- 验收测试(Acceptance test)

### Scrum

#### 基本过程



![image-20200108002540139](C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108002540139.png)

![image-20200108002707247](C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108002707247.png)

Product Backlog

>  product backlog是一个**具有优先级的需求列表**， 并对每个需求进行了粗略的估算。在Scrum中表示可以预知的所有任务，包括未细化的产品功能要求、Bugs、缺陷、用户提出的改进、具竞争力的功能及技术升级等，按优先级定义出来，这些任务可能不是完整的，甚至可能随时会更改或添加。Prodcut Backlog**永远处于不完整状态**，它随着产品及其使用环境的变化而变化，它是动态的，管理层不断对之做出改变，确定产品需求，保证产品适用性、实用性和竞争性。

* Product Backlog 和 Sprint Backlog 区别

  |          | Product Backlog          | Sprint Backlog             |
  | -------- | ------------------------ | -------------------------- |
  | 详细度   | 比较详细                 | 非常详细                   |
  | 估算单位 | Story Points             | 小时                       |
  | 文档归属 | Product Owner            | 开发团队                   |
  | 更新频率 | 一次1周                  | 一次1工作日                |
  | 持续长度 | 整个项目周期             | 一个Sprint                 |
  | 文档名   | Product Backing workbook | Iteration Backlog workbook |

#### 三种角色

* **产品负责人(Product Owner)**：确定产品的功能，负责维护产品Backlog、deadline、priority、ROI；验收结果
* **ScrumMaster**：团队leader，保证开发过程按计划进行；组织每日站会、Sprint计划会议、Sprint评审会议和Sprint回顾会议；通过外在/内在协调，确保团队资源完全可被利用并且全部是高产出的
* **Scrum团队**：在每个Sprint中将产品Backlog中的条目转化成为潜在可交付的功能增量；规模在5-9人；具备交付产品增量所需要的各种技能

#### 六项活动

* Sprint (冲刺)：代表一个2-4周的迭代

* 发布计划会议(Release Planning Meeting) $\rightarrow$Product Backlog

* Sprint计划会议(Sprint Planning Meeting) $\rightarrow$ Sprint Backlog 

   ![image-20200108004351864](C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108004351864.png)

* 每日站会(Daily Scrum Meeting)

   * 短时间高效率讨论问题，强迫报告进度，每日构建，图表展现整个项目进度

     eg.Burndown Chart

     `燃尽图（burn down chart）是在项目完成之前，对需要完成的工作的一种可视化表示。`

* Sprint评审会(Sprint Review Meeting)

* Sprint回顾会议(Sprint Retrospective Meeting)

### 归纳与比较

#### 敏捷开发过程的最佳实践(XP&Scrum)

1. 用户故事(User Story)
2. 结对编程(Pair Programming)
3. 测试驱动的开发(TDD)
4. 持续集成(Continuous Integration)
5. 验收测试(Acceptance Testing)
6. 冲刺/迭代(Sprint / Iteration)
7. 产品清单/冲刺清单(Product backlog / Spring backlog)
8. 燃尽图(Burndown chart)
9. 每日站会(Daily Stand-up)

#### 与传统开发过程模型比较



* 瀑布模型：将全部需求以整体方式向前推进，无迭代——基本模型
* 增量模型：将需求分成多份，串行推进，无迭代 ——串行的瀑布
* RAD模型：将需求分成多份，并行推进，无迭代 ——并行的瀑布
* 原型模型：迭代 ——基本模型
* 螺旋模型：按瀑布阶段划分，各阶段分别迭代(原型+风险分析) ——原型+瀑布
* 敏捷模型：将需求分成尽量小的碎片，以碎片为单位进行高速迭代 ——增量+迭代





## 软件项目管理

### 4P

![image-20200108005423866](C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108005423866.png)

![image-20200108005432094](C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108005432094.png)

#### 人员(People)

##### 软件项目的参与人员

* **高级管理者**：负责定义业务问题

* **项目(技术)管理者**：计划、激励、组织和控制软件开发人员

* **开发人员**：拥有开发软件所需技能的人员

  --系统分析员、系统架构师、设计师、程序员、测试人员、质量保证人员、…

* **客户**：进行投资、详细描述待开发软件需求、关心项目成败的组织/人员

* **最终用户**：一旦软件发布成为产品，最终用户就是直接使用软件的人

##### 软件开发团队的组织方式

主治医师模式：

首席程序员 (Chief-programmer) 处理主要模块的设计和编码，其他成员从各种角度支持他的工作 (backup programmer, admin, tool-smith, specialist)

明星模式：

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108095257273.png" alt="image-20200108095257273" style="zoom:67%;" />

社区模式：

由很多志愿者参与，每个人参与自己感兴趣的项目，贡献力量

适合开源项目

交响乐团模式：

类似于“工厂”，严格遵循预定的生产流程

爵士乐模式：

敏捷团队

功能团队模式

具备不同能力的同事平等协作，共同完成一个项目开发

官僚模式

成员之间不光有技术方面的合作和领导，同时还混进了组织上的领导和被领导关系，跨组织的合作变得比较困难

#### 产品(Product)

##### 产品结构分解（PBS）

确定软件范围$\Rightarrow$通过分层的树型结构来定义和组织项目范围内的所有产出物(产品)，自顶向下，逐级细分

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108102910066.png" alt="image-20200108102910066" style="zoom:67%;" />

#### 过程(Process)

Step 1: 选择合适的软件过程模型

Step 2: 根据所选的过程模型，对其进行适应性修改

Step 3: 确定过程中应包含的工作任务列表

##### 工作分解结构(WBS)

WBS：通过分层的树型结构来定义和组织工作任务之间的分解关系，自顶向下，逐级细分

eg.

![image-20200108104153324](C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108104153324.png)

#### 项目(Project)

* 项目关注的四个方面
  * 范围(Scope)
  * 时间(Time)
  * 成本(Cost)
  * 质量(Quality)

### 可行性分析与估算

* 项目开始之前，需估算工作量、时间、人员

* 确定范围：

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108110032507.png" alt="image-20200108110032507" style="zoom: 67%;" />

* Needs：客户/最终用户的请求、想法和业务需求
* Requirements：对未来系统所应具备的功能的陈述
* Exclusions：将不包含在未来系统中的功能的陈述
* Baseline：对未来系统中应包含的功能的陈述

#### 可行性分析

* 技术可行性
* 经济可行性
* 时间可行性
* 资源可行性

#### 软件项目估算

* 代码行技术，功能点技术，过程估算技术

### 进度计划与监控

#### 任务进度甘特图（Gantt Chart）

* eg.

  <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108111044997.png" alt="image-20200108111044997" style="zoom:67%;" />

  

#### 资源，产出与里程碑

* 将资源分配给任务
  * 资金
  * 人员
  * 设备
  * 环境

* 明确产出结果

* 明确里程碑（项目的关键产出物，标志着某一阶段的完成）

#### 项目进度跟踪

* XP/Scrum敏捷开发中的进度计划与监控

  以“迭代”为单位：每次迭代包含多少个用户故事或用例

  每次迭代为30天左右

  针对每个用户故事，团队成员联合估算和协商开发代价(时间)

使用任务墙(Task Board)/燃尽图(Burndown Chart)等作为进度监控工具，评估迭代的当前进展情况





## 软件演化与配置管理

### 软件演化

* 软件在使用过程中，新的需求不断出现
* 商业环境在不断地变化
* 软件中的缺陷需要进行修复
* 计算机硬件和软件环境的升级需要更新现有的系统
* 软件的性能和可靠性需要进一步改进

**Lehman定律**

* 持续变化：环境变化产生软件修改，软件修改又继续促进环境变化
* 复杂度逐渐增大：软件修改会引入新的错误，造成故障率的升高

### 软件维护

#### 类型

##### 纠错性维护

​	修改软件中的缺陷或不足

##### 适应性维护

​	修改软件使其适应不同的操作环境，包括硬件变化、操作系统变化或者其他支持软件变化等

##### 完善性维护

增加或修改系统的功能，使其适应业务的变化

##### 预防性维护

为减少或避免以后可能需要的前三类维护而提前对软件进行的修改工作

-- 定义为“采用先进的软件工程方法对需要维护的软件或软件中的某一部分(重新)进行设计、编制和测试”

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108115502646.png" alt="image-20200108115502646" style="zoom:67%;" />

#### 内容

##### 程序维护

​	根据使用的要求，对程序进行全部或部分修改

##### 数据维护

​	数据维护指对数据有较大的变动，或者某些数据文件或数据库出现异常时的维护工作

##### 硬件维护

​	硬件人员应加强设备的保养以及定期检修，并做好检验记录和故障登记工作

### 软件配置管理(SCM)

* **软件配置**(software configuration)：由在软件工程过程中产生的所有信息项构成，它可以看作该软件的具体形态(软件配置项)在某一时刻的瞬间映像

* SCM贯穿整个软件生命周期与软件工程过程

#### 目标

- 标识变更
- 控制变更
- 确保变更的正确实现
- 向开发组织内各角色报告变更

#### 基本元素

- 配置项(Configuration Item, CI):源代码和可执行程序，doc，数据

- **基线**(Baseline)：

  已经通过正式评审和批准的软件规格说明或代码，它可以作为进一步开发的基础，并且只有通过正式的变更规程才能修改它

  * 在某个时间点上对产品属性的一致描述，它是定义变化的基础

  ![image-20200108120339212](C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108120339212.png)

- 配置管理数据库(CMDB)：用于保存于软件相关的所有配置项的信息以及配置项之间关系的数据库

  版本控制、相关性跟踪和变更管理、需求跟踪、配置管理、审核跟踪

- 最终硬件库(Definitive Hardware Store, DHS)

- 最终软件库(Definitive Software Library, DSL)





## UML

### 简介

#### 视图

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108121512334.png" alt="image-20200108121512334" style="zoom: 80%;" />

##### Use Case View

* 用例视图：**核心**（包含UML图:用例图）

  描述系统应该具备的功能，即被称为参与者（执行者）的外部用户所能观察到的功能

##### Logical View

* 逻辑视图：（包含UML图：类图、对象图、状态图、时序图、协作图、活动图）

  描述用例视图中提出的系统功能的实现

##### Process View

* 进程视图：（包含UML图：状态图、协作图、组件图、活动图）

  考虑资源的有效利用、代码的并行执行以及系统环境中异步事件的处理

##### Implementation View

* 实现视图：（包含UML图：组件图）

  描述系统的实现模块以及它们之间的依赖关系

##### Deployment View

* 部署视图（组成：部署图）

  显示系统的物理部署，并描述位于节点实例上的运行组件实例的部署情况

#### 模型元素

##### 事物

* 结构事物（structural things）：

  类、接口、协作（交互操作）、用例、活动类(对象)、组件、节点

* 行为事物（behavioral things）：交互、状态机

* 分组事物（grouping things）：包（将有组织的元素分组的机制）

* 注释事物（annotational things）

##### 关系

- 关联（association）

  <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108122815438.png" alt="image-20200108122815438" style="zoom: 80%;" />

- 依赖（dependency）

  <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108122836662.png" alt="image-20200108122836662" style="zoom:80%;" />

- 泛化（generalization）

  <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108122848622.png" alt="image-20200108122848622" style="zoom:80%;" />

- 实现（realization）

  <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108122859585.png" alt="image-20200108122859585" style="zoom:80%;" />

- 聚合（polymerization）

  <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108122911554.png" alt="image-20200108122911554" style="zoom: 80%;" />

#### 扩展组件

* 构造型
* 标记值
* 约束



### 用例图

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108123152597.png" alt="image-20200108123152597" style="zoom:67%;" />

#### 组成

1. 参与者（Actor）

   * 启动者和支持者
     * 启动者是用例的主要服务对象
     * 另一类是扮演支持者角色的参与者（如会员和酒店经营者）

2. 用例（Use Case）

   * **外部可见**的系统功能单元

   事件流

   * 事件流的描述是独立于实现方法的，事件流描述系统“做什么”（比用例更详细）
   * 组成：简要说明、前提条件、后置条件、事件流程（通常用表格描述）

3. 关联关系（Association）

   * 参与者与用例之间：不同的参与者可以访问相同的用例

   <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108133633510.png" alt="image-20200108133633510" style="zoom:50%;" />

4. 包含关系（Include）

   * 用例与用例之间：

     <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108133700782.png" alt="image-20200108133700782" style="zoom:50%;" />

   * 包含用例（客户用例）执行，则被包含用例（提供者用例）必须执行

5. 扩展关系（Extend）

   * 用例与用例之间：扩展用例被定义为基础用例的增量扩展

     <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108133903389.png" alt="image-20200108133903389" style="zoom:50%;" />

   * 扩展关系是把新的行为加入到已有的用例中去

6. 泛化关系（Generalization）

   * 用例与用例之间：泛化关系是一般和特殊的关系

   * 一个用例（父用例）可以被特别地列举为一个或多个子用例，子用例表示父用例的特殊形式

   * 子用例从父用例处继承行为和属性，还可以添加行为或覆盖、改变继承的行为

     <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108134040032.png" alt="image-20200108134040032" style="zoom:50%;" />

#### 常见错误

* 把步骤当成用例

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108134239308.png" alt="image-20200108134239308" style="zoom:70%;" />

* 错误的层次

  <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108134330401.png" alt="image-20200108134330401" style="zoom:80%;" />

  * 把研究对象（边界）由“医院管理系统”偷换成了“医院”



### 活动图

* 它描述活动的顺序，展现从一个活动到另一个活动的控制流
* 活动图在本质上是一种流程图；活动图着重表现从一个活动到另一个活动的控制流

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108134536863.png" alt="image-20200108134536863" style="zoom:67%;" />

#### 组成

1. 动作状态（Action State）

   * 平滑的圆角矩形表示

   * 原子的、不可中断的、瞬时的

   * 可以有入转换，至少有一条出转换

   * 无入口动作和出口动作

     <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108135101009.png" alt="image-20200108135101009" style="zoom: 50%;" />

2. 活动状态（Activity State）

   * 活动状态可以在图标中给出入口动作和出口动作等信息 

   * 非原子的

   * 活动状态可以用另一个活动图表示

     <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108135119641.png" alt="image-20200108135119641" style="zoom:50%;" />

3. 开始点/结束点

   * 开始点

     <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108135242595.png" alt="image-20200108135242595" style="zoom:50%;" />

   * 结束点

     * 整个活动的结束

       <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108135251160.png" alt="image-20200108135251160" style="zoom:50%;" />

     * 子流程的结束

       <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108135258478.png" alt="image-20200108135258478" style="zoom:50%;" />

4. 分支与合并

   <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108135417293.png" alt="image-20200108135417293" style="zoom:67%;" />

5. 分叉与汇合

   * 分叉用将控制流分为两个或者多个**并发运行**的分支
   * 汇合用于**同步**这些并发分支，以达到共同完成一项事务的目的

6. 泳道

   eg.

   <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108135800758.png" alt="image-20200108135800758" style="zoom:67%;" />
   
7. 对象流

   * 是动作状态或者活动状态与对象之间的依赖关系，表示动作使用对象或动作对对象的影响

   eg.

   <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108135950957.png" alt="image-20200108135950957" style="zoom:67%;" />



### 类图

* 描述类、接口及它们之间关系的图
* 显示系统中各个类的**静态**结构

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108140746065.png" alt="image-20200108140746065" style="zoom:67%;" />

#### 组成

1. 类（Class）

   * 名称

   * 属性

     * 语法：[可见性] 属性名 [类型] [=初始值]

       * 可见性：

         公有（Public） “＋”     所有类可见

         私有（Private）“－”    该类及子孙可见

         受保护（Protected）“＃”只对该类本身可见

         包（Package） “～”     只对同一包声明的类可见

       * 

   * 操作

     * 语法：[可见性] 操作名 [(参数列表)] [:返回类型]

   <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108140956377.png" alt="image-20200108140956377" style="zoom: 60%;" />

2. 接口（Interface）

   * 在没有给出对象的实现和状态的情况下对对象行为的描述

     **包含操作但不包含属性**

   * 一个类可以实现一个或多个接口

     <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108141548745.png" alt="image-20200108141548745" style="zoom: 60%;" />

3. 依赖关系（Dependency）

   * 表示两个或多个模型元素之间语义上的关系

     eg.客户以某种形式依赖于提供者

   <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108141653403.png" alt="image-20200108141653403" style="zoom:50%;" />

   * 分类：

     * 使用依赖（Usage）

       * 表示客户使用提供者提供的服务以实现它的行为

       * 调用(call)、参数(parameter)、发送(send)、实例化(instantiate)

     * 抽象依赖（Abstraction）

       * 表示客户与提供者之间的关系，依赖于在不同抽象层次上的事物，包括

       * 跟踪(trace)、精化(refine)、派生(derive)

     * 授权依赖（Permission）

       * 表达一个事物访问另一个事物的能力
       * 访问(access)、导入(import)、友元(friend)

     * 绑定依赖（Binding）

       * 较高级的依赖类型，用于绑定模板以创建新的模型元素
       * 绑定(bind)

   * 

4. 泛化关系（Generalization）

   * 存在于一般元素和特殊元素间的分类关系("is kind of")

   * 可以用于类、用例以及其他模型元素

     <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108143703572.png" alt="image-20200108143703572" style="zoom:50%;" />

5. 关联关系（Association）

   * 指明事物的对象之间的联系

     <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108143743225.png" alt="image-20200108143743225" style="zoom:50%;" />

   * 名称：说明对象关系，非必须

     <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108143833890.png" alt="image-20200108143833890" style="zoom:50%;" />

   * 角色：用以解释对象是如何参与关系的

     <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108143911365.png" alt="image-20200108143911365" style="zoom:50%;" />

   * 多重性：赋给一个端点的多重性表示该端点可以有多少个对象与另一个端点的一个对象关联

     <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108144027475.png" alt="image-20200108144027475" style="zoom:50%;" />

     * 格式：“min .. max” （均为int型）

   * 聚合关系

     * 表示整体与部分关系的关联（“has a”）

       <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108145509123.png" alt="image-20200108145509123" style="zoom:50%;" />

   * 组合关系

     * 聚合关系中的一种特殊情况，是更强形式的聚合，又称强聚合

       <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108145531032.png" alt="image-20200108145531032" style="zoom:50%;" />

6. 实现关系（Realization）

   * 类之间的关系：规格说明（接口）和其实现之间的关系

   <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108145929464.png" alt="image-20200108145929464" style="zoom: 67%;" />

#### 分析阶段类图

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108150030510.png" alt="image-20200108150030510" style="zoom: 67%;" />



### 交互图（时序图/协作图）

* 交互图是描述系统中对象之间通过消息通信的图

#### 序列图（时序图、顺序图）

* 序列图用来描述系统中对象间通过消息进行交互，它强调消息在时间轴上的先后顺序

* 纵轴：时间轴；横轴：交互中各独立的对象

  <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108151436147.png" alt="image-20200108151436147" style="zoom:67%;" />

* 描述用例的实现，它表明了由哪些对象通过消息相互协作来实现用例的功能
* 在序列图中标识了消息发生交互的先后顺序
* **明确类的职责**

> 三种UML图比较

| 用例图                     | 类图                       | 序列图                     |
| -------------------------- | -------------------------- | -------------------------- |
| 动态行为  （系统外在行为） | 静态结构  （系统内在结构） | 动态行为  （系统内在行为） |
| 参与者、用例               | 类                         | 对象                       |
| 包含、扩展、泛化           | 依赖、关联、泛化           | 消息                       |
| 用例描述                   | 事务模式                   | BCE模式                    |
| 业务流程                   | 领域概念                   | 概念与流程的关联           |

##### 组成

1. 对象

   * 对象名:类名

     * 将对象置于序列图顶部意味着在交互开始的时候对象就已经存在了

       如果对象位置不在顶部，那么表示对象是在交互的过程中被创建的

     * 对象的注销：

       在其生命线终止点放置一个 “X” 符号，该点通常是对删除或取消消息的回应

2. 生命线

   * 一条垂直的虚线，表示序列图中的对象在一段时间内的存在；
     * 每个对象底部中心的位置都带有生命线
   * 一个时间线，从序列图的顶部一直延伸到底部，所用的时间取决于交互持续的时间

3. 消息

   * 对象之间某种形式的通信，它可以激发某个操作、唤起信号或导致目标对象创建或撤销
     * 消息可以是信号，也可以是调用
     * 消息可以用于在对象间传递参数
     * UML中用箭头表示

   * 类型：
     * 调用：调用某个对象的一个操作（通常格式为“对象名.成员方法”）
     * 返回：被调用的对象向调用者返回一个值
     * 发送：向对象发送一个信号(异步)
     * 创建和注销：创建和销毁一个对象

4. 激活

   * 激活（Activation）表示该对象被占用以完成某个任务
   * 去激活（Deactivation）指的则是对象处于空闲状态、在等待消息

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108152313523.png" alt="image-20200108152313523" style="zoom:67%;" />

##### BCE模式

* 系统分析阶段采用的分析模式
* B:Boudary
  * **边界类**用来隔离系统内部和外部，负责接收参与者的消息
* C: Control
  * **控制类**对应用例，用来控制用例执行期间的复杂运算或者业务逻辑
* E: Entity
  * **实体类**对应于类图中领域概念中的类
  * 封装了数据结构和数据存储有关的类

* 4项原则
  * 针对每一个用例，可以对应生成一个控制类
  * 参与者对象只能跟边界对象互动
  * 实体对象不能发送消息给边界对象和控制对象
  * 特别情况，如只是对数据进行增加、删除、修改和查询操作也可以不设置控制对象，让边界对象直接发送消息给实体对象，以提高执行速度

##### 组合片段

* 表示循环和分支
* 可以使用组合片段来描述可能发生在不同场合的变体 

###### 操作符

* 每个交互片段都有一个操作符，操作符决定了交互片段的执行方式

* opt:包含一个可能发生或可能不发生的序列，可以在临界条件中指定序列发生的条件

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108155728579.png" alt="image-20200108155728579" style="zoom:80%;" />

* alt:可以在每个片段中设置一个临界条件来指示该片段可以运行的条件

* loop:片段重复一定次数，可以在临界条件中指示片段重复的条件

* break:如果执行此片段，则放弃序列的其余部分，可以使用临界来指示发生中断的条件

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108155844606.png" alt="image-20200108155844606" style="zoom:67%;" />

* par:并行处理，片段中的事件可以交错

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108155858220.png" alt="image-20200108155858220" style="zoom:80%;" />

* critical:指示此片段中的消息不得与其他消息交错，通常是一些原子性操作

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108155942315.png" alt="image-20200108155942315" style="zoom:67%;" />

#### 协作图

* 描述了系统中，对象间通过消息进行的交互，强调了对象在交互行为中承担的角色

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108160024654.png" alt="image-20200108160024654" style="zoom: 67%;" />

##### 组成

1. 对象（Object）
2. 链（Link）
3. 消息（Message）

* 序列图与协作图都表示对象之间的交互作用，只是它们的侧重点有所不同
  * 序列图描述了交互过程中的**时间顺序**，但没有明确地表达对象之间的关系
  * 协作图描述了对象之间的**关系**，但时间顺序必须从顺序号获得
  * 两种图的语义是**等价的**，可以从一种形式的图转换成另一种形式的图，而不丢失任何信息



### 状态图

#### 组成

1. 状态（State）：指在对象的生命周期中的某个条件或者状况

   * 初始状态（Initial State）用实心圆点表示，通常带有已经过初始化的含义

   * 终止状态（Final State）用圆形内嵌圆点表示

   <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108160427714.png" alt="image-20200108160427714" style="zoom: 50%;" />

2. 转移（Transaction）：表示对象将在源状态（Source State）中执行一定的动作，并在某个特定事件发生而且某个特定的警界条件满足时进入目标状态（Target State）

   * 带箭头的实线表示

   <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108160531379.png" alt="image-20200108160531379" style="zoom:50%;" />

3. 触发事件（Trigger）：是转移的诱因

   <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108160759427.png" alt="image-20200108160759427" style="zoom:50%;" />

4. 警界条件（Guard Condition）：当警界条件满足时，事件才会引发状态转移

5. 结果（Effect）：对象状态转移后的结果

6. 动作（Actions）：一个可执行的**原子操作**，不可中断的，其执行时间是可忽略不计的

   * 分类：EntryActions,DoActions,ExitActions

     <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108160932202.png" alt="image-20200108160932202" style="zoom: 50%;" />

7. 组合状态：嵌套在另外一个状态中的状态称，一个含有子状态的状态被称作组合状态
<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108161029355.png" alt="image-20200108161029355" style="zoom: 50%;" /><img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108162357801.png" alt="image-20200108162357801" style="zoom:50%;" />

8. 进入节点

   * 由于一些原因并不会执行初始化，而是直接通过一个节点进入状态，则此节点称之为进入节点或选择节点

     <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108162624703.png" alt="image-20200108162624703" style="zoom:50%;" />

9. 退出节点

   * 从状态内部的子状态转移到外部的状态，在边界处要经过退出节点

     <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108162715060.png" alt="image-20200108162715060" style="zoom:50%;" />

10. 历史状态

    * 为了记住从组合状态中退出时所处的子状态，当再次进入组合状态，可直接进入这个子状态，而不是再次从组合状态的初态开始

      <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108162813842.png" alt="image-20200108162813842" style="zoom: 67%;" />

11. 并发

    * 组合状态在某一时刻可以同时达到多个子状态 

    <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108162855422.png" alt="image-20200108162855422" style="zoom: 67%;" />

    





##  需求分析

### 软件需求概念

#### 需求分类

##### 业务需求

* 客户对于系统的高层次目标要求(high-level objectives) ，定义了项目的远景和范畴(vision and scope)

##### 用户需求

* 从用户角度描述的系统功能需求与非功能需求，通常只涉及系统的外部行为而不涉及内部特性

##### 功能需求

* 系统应该提供的功能或服务，通常涉及用户或外部系统与该系统之间的交互，不考虑系统内部的实现细节

##### 非功能需求

* 效率、可靠性等等

##### 业务规则

* 对某些功能的可执行性或内部执行逻辑的一些限定条件

##### 约束条件

* 系统设计和实现时必须满足的限制条件，对其进行权衡或调整是相当困难的，甚至是不可能的

##### 外部接口需求

* 描述系统与其所处的外部环境之间如何进行交互

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108163505807.png" alt="image-20200108163505807" style="zoom:67%;" />



### 用例建模

#### 用户故事

* 对软件用户（或所有者）有价值的功能性的简明、书面描述
* 支持敏捷迭代计划

#### 用例建模

##### 用例

* 表示系统所提供的服务或可执行的某种行为
* 站在用户角度定义软件系统的外部特征

* 行为序列、系统执行、可观测到的/有价值的、特定的角色

##### 用例建模基本过程

1. 识别并描述参与者(actor)；

2. 识别用例(use case)，并给出简要描述；

3. 识别参与者与角色之间的通讯关联(Association)；

4. 给出每一个用例的详细描述

   * 单纯的用例图并不能描述完整的信息，需要用文字描述不能反映在图形上的信息

   <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108165055923.png" alt="image-20200108165055923" style="zoom:67%;" />

5. 细化用例模型

### 结构化分析

* 结构化分析方法(SA)：将待解决的问题看作一个系统，从而用系统科学的思想方法(抽象、分解、模块化)来分析和解决问题

#### 数据流图（DFD）

* 数据流图：用处理、外部实体、数据流以及数据存储来（DFD）表示系统需求的图表

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108165547117.png" alt="image-20200108165547117" style="zoom:67%;" />

* 关联图：在单个处理符号中概括系统内所有处理活动的DFD
  * 当一个系统响应事件较多时，常常将系统分成多个子系统，并为每个子系统创建一张关联图

eg.

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108165848212.png" alt="image-20200108165848212" style="zoom:67%;" />

* DFD片段：用一个单一处理符号表示系统响应一个事件的DFD
  * 一个DFD片段是为事件表中的每一个事件创建的

* DFD的0层图：
     将一个系统或子系统的所有DFD片段组合到一个单个的DFD图
     中，这样的DFD图称为事件分离的系统模型/0层图

eg.

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108170021502.png" alt="image-20200108170021502" style="zoom:67%;" />

* **构造DFD图的7±2规则：**
  * 单个DFD中不应有超过7±2个处理
  * 单个DFD中不应超过7±2个数据流进出同一个处理/数据存储

* **保持数据流一致性**
  *  一个“处理”和该“处理”被详细分解后在数据流内容上应该一致
  * 对一个“处理”，**有数据流入则必须有相对应的数据流出**
  * 对一个“处理”，**有数据流出则必须有相对应的数据流入**

##### 典型错误

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108170425267.png" alt="image-20200108170425267" style="zoom:67%;" />

* 总结：

  * 在关联图中不画数据存储

  * 数据流不反映处理顺序，显示数据通过系统的流程，
     因此“处理”可以并行工作

  * “处理/数据存储”既要有输入，又有输出

    * 黑洞：输入数据流不完全用来产生输出数据流

    * 奇迹：输出数据流不完全依赖于输入数据流

#### 数据字典（DD）

* 数据项定义，数据结构定义，数据流描述，数据存储描述

* 数据处理：给出处理的流程和说明信息
  * 数据处理名
  * 数据处理说明
  * 输入数据： ｛数据结构｝
  * 输出数据： ｛数据结构｝
  * 处理过程简要描述

#### 数据分析（ERD）

* 实体关系图

  * 数据存储需求包括数据实体、数据实体的属性以及它们之间的关系
  * <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108171137666.png" alt="image-20200108171137666" style="zoom:60%;" />

  

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108171120209.png" alt="image-20200108171120209" style="zoom: 67%;" />



### 面向对象分析

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108171620881.png" alt="image-20200108171620881" style="zoom:67%;" />

业务领域分析$\Rightarrow$发现和定义对象和类$\Rightarrow$识别对象的外部联系$\Rightarrow$建立系统的静态结构模型

$\Rightarrow$建立系统的动态行为模型

#### 建立静态结构模型

1. 从用例模型入手，识别分析类；

   * 分析类直接与应用逻辑相关，而不关注于技术实现的问题（实体类、边界类、控制类（对用例行为的封装））
   * 三种分析类之间是“关联”关系(association)、多对多(m:n)关系：

   * **识别边界类**：一个参与者与一个用例之间的交互或通信关联对应一个边界类
     * 边界类应关注于参与者与用例之间交互的信息或者响应的事件，不要描述窗口组件等界面的组成元素
   * **识别控制类**：一般来说，一个用例对应一个控制类
     * 当用例比较复杂时，特别是产生分支事件流的情况下，一个用例可以有多个控制类
     * 在有些情况下，用例事件流的逻辑结构十分简单，这时没有必要使用控制类，边界类可以实现用例的行为
     * 如果不同用例包含的任务之间存在着比较密切的联系，则这些用例可以使用一个控制类，其目的是复用相似部分以便降低复杂性

   * **识别实体类**：“角色”(actor)是否一定是实体类？—— **NO**

2. 描述各个类的属性；

   * 对UI类型的边界类：
     * 需要actor输入的各个数据
     * 系统反馈给actor的各个数据
     * 需要临时保存的、用于在边界类和控制类之间传递的临时数据（例如登录次数）

   * 对API类型的边界类：
     * 需要向外部系统(软件/硬件)传递的数据
     * 需要从外部系统(软件/硬件)接收的数据

   * 控制类的属性：
     * 从UI接收的数据
     * 为进行事件流执行所需的临时数据
     * 需要调用的实体类
     * 经过计算之后、需要发送给UI的数据

   * 实体类的属性：

     * 基本属性：

       考虑对象需要系统保存的信息，找出对象的相应属性

     * 状态属性：

       识别对象需要区别的状态，考虑是否需要增加一个属性来区别这些状态

     * 关联属性：

       确定属性表示整体与部分结构和实例连接

     * 派生属性：

       通过计算其他属性的值所得到的新属性（例如实发工资、扣税）

3. 定义各个类的操作；

   * 通过动词分析获得操作
   * 操作四种类型
     * 以某种方式操作数据（增加、删除、重新格式化、选择等）
     * 执行计算的操作
     * 请求某个对象的状态的操作
     * 监视某个对象发生某个控制事件的操作

   * 边界类的操作：
     * 提供给用户的、可在UI上进行的各类操作
     * 对从控制类返回的数据进行各类临时处理而进行的操作
     * 提供给其他系统的API

   * 控制类的操作：
     * 对从边界类接收到的数据进行各类临时处理而进行的操作
     * 向实体类所发出的调用操作
     * 对从实体类接收到的数据进行临时处理而进行的操作

   * 实体类的操作：
     * 对属性进行CRUD的操作
     * 对状态进行更新的操作
     * 辅助操作

4. 建立类之间的关系； 

   * 五种关系：
     * 泛化(generalization)、关联(association)、组合(composition)、聚合(aggregation)、依赖(dependency)

5. 绘制类图(class diagram)

   * 分析类图：描述各边界类、实体类、控制类之间的关联关系，无需刻画属性与操作集

     领域类图：可以不包含边界类与控制类，侧重描述各实体类之间的五种关系，需要给出详细的属性与操作集合

   分析类图：                                      

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108173133963.png" alt="image-20200108173133963" style="zoom:67%;" />

​		领域类图：

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108173158032.png" alt="image-20200108173158032" style="zoom:67%;" />

#### 建立动态行为模型

##### 时序图

* 将用户与分析类结合在一起，实现将用例的行为分配到所识别的分析类中

  是强调消息时间顺序的交互图，描述了对象之间传送消息的时间顺序，表示用例中的行为顺序

* 画法参考UML中时序图

* 绘制步骤：
  * 列出启动该用例的参与者
  * 列出启动用例时参与者使用的边界对象
  * 列出管理该用例的控制对象
  * 根据用例描述的流程，按时间顺序列出分析类之间进行消息访问的序列

* 每个用例对应一张时序图

时序图

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108173621312.png" alt="image-20200108173621312" style="zoom:67%;" />

协作图

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108173645516.png" alt="image-20200108173645516" style="zoom:67%;" />





## 设计

### 结构化设计

#### 结构图

* 以模块为基础、以模块间的调用为关联所构成的图
  * 通过层次的方法来描述系统每部分的功能和子功能
  * 展示计算机程序模块间的联系

##### 从DFD片段建立一个结构图的步骤

* 确定主要的信息流
* 找出能代表输入和输出间最基本变化的过程
* 重画数据流图并把输入放在左边，输出放在右边
* 初步建立一个结构图草图
* 加入其它模块实现下列功能
  * 数据输入、数据处理、数据输出

* 使用结构化语言或决策树添加模块间逻辑

* 进一步求精

### 数据库设计

#### 数据库逻辑模型设计--ERD

1. 识别所有“自然”数据实体（Entity）
   * 来自DFD中的全部“数据存储”
   * 来自“分析类图”中的部分“类”
2. 为数据实体命名
3. 给出实体的属性
4. 识别实体之间的关联关系及关联重数
   * 关联关系需命名
   * 关联重数需判别（1:1、1:M、M:N）
5. 建立关联实体（“人造”实体）来消除M:N重关系
6. 实体规范化（一般需满足3NF）
7. 评价ERD质量并做必要的改进

eg.

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108181325458.png" alt="image-20200108181325458" style="zoom:67%;" />

* 规范化

  * §范式（Normal Form）的分类

    –**1NF** – 没有重复的属性或属性组

    –**2NF** – 是1NF 且每个非主属性均函数依赖于
          主属性(主键)

    –**3NF** – 是2NF且非主属性间均不存在函数依赖

#### 物理数据库设计及建立

1. 为每个实体创建一个二维表
2. 为每个字段选择适当的数据类型和取值范围
3. 定义每个表的主键(PK-Primary Key)
4. 针对1:M关联关系的子表添加外键(FK-Foreign Key，即对应主表主键)
5. 定义完整性约束
   * 域的完整性：设定字段的取值范围
   * 参照完整性： 用PK、FK、表级触发器来实现
   * 用户定义完整性： 定义一些业务规则，用存储过程和触发器来实现

#### OO分析类图映射到ERD

* 对象关系映射ORM

  通过使用描述对象和数据库之间映射的元数据，将OO系统中的对象自动持久化到关系数据库中

##### 映射策略

* 最简单的映射策略—— “一类一表”：表中的字段对应于类的属性，表中的每一行数据记录对应类的实例(即对象)

* 不管是1:1、1:n还是m:n的关联关系，均可以采用以下途径映射为关系数据表：

  –A与B分别映射为独立的数据表，然后再加入一张新表来存储二者之间的关联

* 1：1和m:n的关联关系：

  	​						             <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108181845923.png" alt="image-20200108181845923" style="zoom:60%;" />

  <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108181929235.png" alt="image-20200108181929235" style="zoom:60%;" />

* 1：n的关联关系

​                                     <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108182012998.png" alt="image-20200108182012998" style="zoom:60%;" />

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108182227992.png" alt="image-20200108182227992" style="zoom:67%;" />

* 将组合/聚合关系映射到关系数据库

  * 实现方法：类似于1:n的关联关系

    –建立“整体”表

    –建立“部分”表，其关键字是两个表关键字的组合

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108182548985.png" alt="image-20200108182548985" style="zoom: 67%;" />

* 将继承关系映射到关系数据库

  * 策略1：分别建立父类和子类的三张数据表

    <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108182708750.png" alt="image-20200108182708750" style="zoom:67%;" />

  * 策略2：将子类的属性上移到父类所对应的数据表中，该表包括父类的属性、各子类的全部属性

  * 策略3：将父类的属性下移到各个子类所对应的数据表中





## 软件测试

### 单元测试

* 单元测试是对软件基本组成单元进行的测试，有时也称“组件测试”

* 单元测试环境

  * 驱动模块(driver)：模拟被测模块的上一级模块，接收测试数据，把这些数据传送给所测模块，最后再输出实际测试结果

  * 桩模块(stub)：模拟被测单元需调用的其他函数接口，模拟实现子函数的某些功能

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108183438382.png" alt="image-20200108183438382" style="zoom:67%;" />

![image-20200108183532907](C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108183532907.png)

### 黑盒测试

* 又称“功能测试”、“数据驱动测试”或“基于规格说明书的测试”，是一种从用户观点出发的测试

* 将测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明

#### 等价类划分

* 等价类：输入数据的某个子集，在该子集合中的各个输入数据对于揭露程序中的错误都是等效的，并合理地假定“测试某等价类的代表值就等于对这一类其它值的测试
  * 在每一个等价类中选取少量有代表性的数据作为测试的输入条件，就可以用少量代表性的测试数据，并取得较好的测试结果

* 基本原则：
  * 每个可能的输入属于某一个等价类
  * 任何输入都不会属于多个等价类
  * 用等价类的某个成员作为输入时，如果证明执行存在误差，那么用该类的任何其他成员作为输入，也能检查到同样的误差

* 有效等价类/无效等价类
  * 设计测试用例时，要同时考虑这两种等价类

* 划分标准

  * **完备测试、避免冗余**

  * 将输入数据的集合(P)划分为一组子集(E1, E2, …, En)，并尽可能满足：
    $$
    E_1\bigcup E_2\bigcup...\bigcup E_n=P
    $$

    $$
    E_i\bigcap E_j = \emptyset（i ≠ j 且 1 ≤ i , j ≤ n）
    $$

* 六大原则：
  * **原则1：**在输入条件规定了取值范围或值的个数的情况下，则可以确立1个有效等价类和2个无效等价类
  * **原则2：**在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可确立1个有效等价类和1个无效等价类
  * **原则3：**在输入条件是一个布尔量的情况下，可确定1个有效等价类和1个无效等价类
  * **原则4：**在规定了输入数据的一组值(假定n个)、并且程序要对每一个输入值分别处理的情况下，可确立n个有效等价类和1个无效等价类
  * **原则5：**在规定了输入数据必须遵守的规则的情况下，可确立1个有效等价类(符合规则)和n个无效等价类(从不同角度违反规则)
  * **原则6：**在确知已划分的等价类中各元素在程序处理中的方式不同的情况下，则应再将该等价类进一步的划分为更小的等价类
* 格式:测试用例 = {测试数据+期望结果}
* 设计测试用例步骤：
  * 为每一个等价类规定一个唯一的编号
  * 设计一个新的测试用例，使其尽可能多的覆盖尚未被覆盖的有效等价类；重复这一步，直到所有的有效等价类都被覆盖为止
  * 设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类；重复这一步，直到所有的无效等价类都被覆盖为止



#### 边界值分析

* 边界值分析是等价类测试的特例，主要是考虑等价类的边界条件，在等价类的“边缘”选择元素

eg.

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108184955780.png" alt="image-20200108184955780" style="zoom:80%;" />

* 通常情况下，软件测试所包含的边界检验有几种类型：数字、字符、位置、重量、大小、速度、方位、尺寸、空间等
* 相应地，以上类型的边界值应该在：最大/最小、首位/末位、上/下、最快/最慢、最高/最低、 最短/最长、 空/满等情况下 

* 边界值分析原则
  * **原则1：**如果输入条件规定了值的范围，则应取刚达到这个范围的边界的值，以及刚刚超越这个范围边界的值作为测试输入数据
  * **原则2：**如果输入条件规定了值的个数，则用最大个数、最小个数、比最小个数少1,比最大个数多1的数据作为测试数据
  * **原则3：**将原则1和原则2应用于输出条件，即设计测试用例使输出值达到边界值及其左右的值
  * **原则4：**如果程序的规格说明给出的输入域或输出域是有序集合，则应选取集合的第一个元素和最后一个元素作为测试用例
  * **原则5：**如果程序中使用了一个内部数据结构，则应当选择这个内部数据结构的边界上的值作为测试用例
  * **原则6：**分析规格说明，找出其它可能的边界条件



### 白盒测试

* 把测试对象看做一个透明的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试

* **设计良好的测试用例，使之尽可能完全覆盖软件的内部实现**

Venn Diagram

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108185401848.png" alt="image-20200108185401848" style="zoom:67%;" />

* 白盒测试的特点：

  以程序的内部逻辑为基础设计测试用例，又称逻辑覆盖法

  应用白盒法时，手头必须有程序的规格说明以及程序清单

##### 覆盖标准：

* 逻辑覆盖（发现错误能力从弱到强）

  * 语句覆盖：每条语句至少执行一次

  * 判定覆盖(分支覆盖)：每一判定的每个分支至少执行一次

  * 条件覆盖：每一判定中的每个条件，分别按“真”、“假”至少各执行一次

  * 判定/条件覆盖：同时满足判定覆盖和条件覆盖的要求

  * 条件组合覆盖：求出判定中所有条件的各种可能组合值，每一可能的条件组合至少执行一次

    <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108190321719.png" alt="image-20200108190321719" style="zoom:67%;" />

* 控制结构覆盖

  * 基本路径测试
  * 循环测试
  * 条件测试
  * 数据流测试

##### 基本路径法

* 路径测试：设计足够多的测试用例，覆盖被测试对象中的所有可能路径

* 基本路径测试(Basic path test)：

  在程序控制图的基础上，通过分析控制构造的环行复杂性，导出基本可执行路径集合，从而设计测试用例

  设计出的测试用例要保证在测试中程序的每一个基本独立路径至少执行一次。

###### 1.画出程序的控制流图

* 图中的每一个圆称为流图的结点，代表一条或多条语句

* 流图中的箭头称为边或连接，代表控制流

![image-20200108190529980](C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108190529980.png)

![image-20200108190613995](C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108190613995.png)

* 如果判断中的条件表达式是由一个或多个逻辑运算符 (OR, AND, NAND, NOR) 连接的复合条件表达式，则需要改为一系列只有单条件的嵌套的判断

* **独立路径(基本路径)：**一条程序执行的路径，至少包含一条在定义该路径之前的其他基本路径中所不曾用过的边(即：至少引入程序的一个新处理语句集合或一个新条件)

###### 2.计算圈复杂度

* 圈复杂度是一种为程序逻辑复杂性提供定量测度的软件度量，将该度量用于计算程序的基本的独立路径数目，为确保所有语句至少执行一次的测试数量的上界

* 方法

  ①流图中区域的数量

  ②给定流图G的圈复杂度V(G)，定义为V(G)=E-N+2，E是流图中边的数量，N是流图中结点的数量

  ③给定流图G的圈复杂度V(G)，定义为V(G)=P+1，P是流图G中判定结点的数量

###### 3.导出测试用例

* 根据上面的计算方法，可得出四个独立的路径
* V(G)值正好等于该程序的独立路径的条数

###### 4.准备测试用例

* 测试用例 = {测试数据+期望结果}
* 预期结果是从函数说明中导出，不能根据程序结构中导出！

##### 循环测试法

###### 循环类型

![image-20200108191252548](C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200108191252548.png)

* 对于**简单循环**，测试应包括以下几种，其中的n表示循环允许的最大次数
  * 零次循环：从循环入口直接跳到循环出口
  * 一次循环：查找循环初始值方面的错误
  * 二次循环：检查在多次循环时才能暴露的错误
  * m次循环：此时的m＜n，也是检查在多次循环时才能暴露的错误
  * n(最大)次数循环、n+1(比最大次数多一)次的循环、n-1(比最大次数少一)次的循环

* 对于**嵌套循环：**

  * 从最内层循环开始，设置所有其他层的循环为最小值
  * 对最内层循环做简单循环的全部测试。测试时保持所有外层循环的循环变量为最小值；另外，对越界值和非法值做类似的测试

  * 逐步外推，对其外面一层循环进行测试；测试时保持所有外层循环的循环变量取最小值，所有其它嵌套内层循环的循环变量取“典型”值

  * 反复进行，直到所有各层循环测试完毕

  * 对全部各层循环同时取最小循环次数，或者同时取最大循环次数对于后一种测试，由于测试量太大，需人为指定最大循环次数

* 对于**串接循环**，要区别两种情况
  * 如果各个循环互相独立，则串接循环可以用与简单循环相同的方法进行测试
  * 如果有两个循环处于串接状态，而前一个循环的循环变量的值是后一个循环的初值；则这几个循环不是互相独立的，则需要使用测试嵌套循环的办法来处理 

* 对于**非结构循环**，不能测试，应重新设计循环结构，使之成为其它循环方式，然后再进行测试